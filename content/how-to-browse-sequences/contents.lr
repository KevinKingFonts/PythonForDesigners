_model: chapter
---
title: How to Browse Sequences
---
abstract: Never heard of tuples and lists? Here we go!
---
sort_key: 11
---
visual_abstract: abstract-11.svg
---
body:

<p>We already had a taste of what sequences are thanks to strings. But strings only include  text. What if we need to store a bunch of numerical values? Or some strings together with numerical values?</p>

<p>Python provides two standard data types for generic content: a mutable one, <inline_code>list()</inline_code>, and an immutable one, <inline_code>tuple()</inline_code>. They store an ordered sequence of <em>value references</em>. This means that if a list contains another list – of course this is possible – the inner one will not be copied inside the container, but a reference to it will be stored.</p>

<p>In Python a list is delimited by the characters <inline_code>[]</inline_code>, while a tuple is delimited by characters <inline_code>()</inline_code>.</p>

<p>Here’s a list:</p>

<pre_code>years = [2018, 2017, 2016, 2015]</pre_code>

<large_image src="list.svg"></large_image>

<p>Now, this is a tuple:</p>
<pre_code>coordinates = (10.4, 20.2)</pre_code>

<large_image src="tuple.svg"></large_image>

<p>As we said, elements in lists and tuples are of arbitrary nature: they can be any kind of object, None included. They can be empty too.</p>

<p>Emptiness usually does not make much sense for tuples, given they cannot be modified once created. Instead it is very common to initiate an empty list which will be populated during an iterative process triggered by a while or for construct. Consider the following example:</p>

<pre_code>from random import random
myRandomNumbers = []    # empty list 
for ii in range(20):
    myRandomNumbers.append(random())</pre_code>

<p>The constructor <inline_code>list()</inline_code> and <inline_code>tuple()</inline_code> accept any kind of iterable as argument like strings or lists or tuples. They “listify” or “tuplefy” their arguments. For example, if a string is passed as argument to a <inline_code>list()</inline_code> function, the result will be a container where each character is stored separately:</p>

<pre_code>from string import ascii_lowercase
myLowercase = list(ascii_lowercase)
print(myLowercase)</pre_code>

<p>At this point, you might ask yourself: why both tuples and lists? Aren’t lists enough? Apart from the difference in terms of mutability, there is a semantic difference in the usage of tuples and lists.</p>

<p>While tuples are used to store heterogeneous data structures, lists are ordered sequences of the same stuff. Take note that they have the same degree of freedom concerning data types, it’s just a matter of semantics.</p>

<p>Let’s consider the following scenario: it’s time for a quick ride on our bike and we would like to track our journey using an application installed on a smartphone. Let’s assume this application is written in Python. Every few seconds the application will ask the smartphone hardware for:</p>
<ul><li>gps coordinate x</li>
<li>gps coordinate y</li>
<li>date and time</li></ul>

<pre_code>position = (x, y, dateTime)</pre_code>

<p>This data will be then organized in a tuple. Since the length of the container does not need to be flexible (e.g. we know we won’t add a z index to it) but just to record a state through multiple values, a tuple is a good choice.</p>

<p>The application’s goal is to track a route, which is a sequence of multiple position instances. So, the application needs a container which is flexible and can be extended until the end of the journey: a list.</p>

<pre_code>route = [position01,
         position02,
         position03]
</pre_code>

<p>Once finished, the route of the journey is saved on the smartphone memory. A standard table would suit very well the purpose.</p>

<large_image src="list-table.svg"></large_image>

<section_title>Sequence Properties for Lists and Tuples</section_title>

<ul><li>accessing</li>
<li>slicing</li>
<li>check containment</li>
<li>test equality</li>
<li>natural order</li>
<li>concatenation</li></ul>

<section_title>List Methods</section_title>

<p>As we said, a list is a flexible container, which means that once created, it can be manipulated in multiple ways. Python provides a few specific methods for it</p>

<p>.append(item)</p>
<pre_code># create a list
myList = [1, 'b', 2]
# append an element at the end of the list
myList.append('d')
# result: [1, 'b', 2, 'd']</pre_code>

<large_image src="append.svg"></large_image>

<p>.extend(iterable)</p>

<pre_code>from string import ascii_lowercase, ascii_uppercase
# convert from strings to lists using the list() constructor
latinLowercase = list(ascii_lowercase)
latinUppercase = list(ascii_uppercase)
# create an empty list for the complete alphabet
latinAlphabet = []
# extend the empty list with uppercase and lowercase
latinAlphabet.extend(latinUppercase)
latinAlphabet.extend(latinLowercase)
# result: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']</pre_code>

<large_image src="extend.svg"></large_image>

<p>.insert(index, item)</p>

<pre_code>someCoordinates = [(11.2, 32.1),
                   (43.9, 14.8)]

firstPoint = (34.1, 76.4)
someCoordinates.insert(0, firstPoint)
# result: [(34.1, 76.4), (11.2, 32.1), (43.9, 14.8)]
lastPoint = (63.1, 87.3)
someCoordinates.insert(len(someCoordinates), lastPoint)
# result: [(34.1, 76.4), (11.2, 32.1), (43.9, 14.8), (63.1, 87.3)]
aPoint = (87.4,  6.2)
someCoordinates.insert(2, aPoint)
# result: [(34.1, 76.4), (11.2, 32.1), (87.4, 6.2), (43.9, 14.8), (63.1, 87.3)]
anotherPoint = (45.9, 98.7)
someCoordinates.insert(200, anotherPoint)
# result: [(34.1, 76.4), (11.2, 32.1), (87.4, 6.2), (43.9, 14.8), (63.1, 87.3), (45.9, 98.7)]
# insert does not complain if the index is way bigger than the list
# it will put the element at the end of the list without raising an IndexError</pre_code>

<large_image src="insert.svg"></large_image>

<exercise_wrapper><exercise_content><p>transform a right-angled triangle in a square adding a point</p></exercise_content></exercise_wrapper>

<p>    .remove(item)</p>
<pre_code>myRandomNumbers = [8, 6, 5, 5, 0, 1, 7, 7, 6, 7, 2, 5, 8, 6, 4, 7]
myRandomNumbers.remove(5) # remember: item is not the position index!
# result: [8, 6, 5, 0, 1, 7, 7, 6, 7, 2, 5, 8, 6, 4, 7]
myRandomNumbers.remove(5)
# result: [8, 6, 0, 1, 7, 7, 6, 7, 2, 5, 8, 6, 4, 7]
myRandomNumbers.remove(0)
# result: [8, 6, 1, 7, 7, 6, 7, 2, 5, 8, 6, 4, 7]
myRandomNumbers.remove(0)
# result: ValueError: list.remove(x): x not in list
# check if the list contains the element you want to remove
# with in keyword
if 0 in myRandomNumbers:
    myRandomNumbers.remove(0)
# result: [8, 6, 1, 7, 7, 6, 7, 2, 5, 8, 6, 4, 7]
</pre_code>

<large_image src="remove.svg"></large_image>

<p>.pop(index)</p>

<pre_code>myRandomNumbers = [8, 6, 5, 5, 0, 1, 7, 7, 6, 7, 2, 5, 8, 6, 4, 7]
aNumber = myRandomNumbers.pop()
# aNumber: 7
# myRandomNumbers: [8, 6, 5, 5, 0, 1, 7, 7, 6, 7, 2, 5, 8, 6, 4]
aNumber = myRandomNumbers.pop(0)
# aNumber: 8
# myRandomNumbers: [6, 5, 5, 0, 1, 7, 7, 6, 7, 2, 5, 8, 6, 4]
aNumber = myRandomNumbers.pop(5)
# aNumber: 7
# myRandomNumbers: [6, 5, 5, 0, 1, 7, 6, 7, 2, 5, 8, 6, 4]
aNumber = myRandomNumbers.pop(24)
# result: IndexError: pop index out of range
# check the len of the list before using pop
# with built-in function len()</pre_code>

<large_image src="pop.svg"></large_image>

<p>.index(item)</p>
<pre_code>from string import ascii_lowercase
myLowercase = list(ascii_lowercase)
myIndex = myLowercase.index('f')
# myIndex: 5</pre_code>

<large_image src="index.svg"></large_image>

<p>.sort()</p>
<pre_code>percents = [0.362, 0.782, 0.183, 0.045, 0.549]
percents.sort()
# result: [0.045, 0.183, 0.362, 0.549, 0.782]</pre_code>

<large_image src="sort.svg"></large_image>

<p>.reverse()</p>

<pre_code>from string import ascii_lowercase
flippedLowercase = list(ascii_lowercase)
flippedLowercase.reverse()
# result: ['z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']</pre_code>

<large_image src="reverse.svg"></large_image>

<section_title>For Syntax</section_title>
<p>Python provides a for-loop syntax which is useful to iterate over a series of elements. Where while comes in handy when we need to keep doing something until a condition is matched,for is preferable when we need to browse a container. for can be used with any kind of <em>iterable</em>, which is a wider notion than sequences. Technically, an iterable can be non-sorted (as sets or dicts).</p>

<p>Here’s the general for construct:
</p>

<pre_code>for eachElement in iterable:
    body</pre_code>

<p>Note that the body is four spaces indented rightwards. <inline_code>for</inline_code> and <inline_code>in</inline_code> are protected keywords. <inline_code>eachElement</inline_code> is an identifier to which the body can refer to. Of course its name is arbitrary, it only needs to respect the standard rules for identifiers.</p>

<large_image src="for.svg"></large_image>

<p>The iterable can be created either before the <inline_code>for</inline_code> opening statement or created on the spot. Meaning that this example:</p>

<pre_code>myList = [1, 2, 3]
for eachNumber in myList:
    print(eachNumber)</pre_code>

<p>is equivalent to:</p>

<pre_code>for eachNumber in [1, 2, 3]:
    print(eachNumber)</pre_code>

<p>This also means that we could invoke a function which is able to generate an iterable on the spot</p>

<pre_code>def makeList():
    return [1, 2, 3]

for eachNumber in makeList():
    print(eachNumber)</pre_code>

<p>Python provides a function that you will use very often in your coding routine: <inline_code>range()</inline_code>. This function returns an iterator –not a real list– which will provide a sequence of integers according to the following arguments</p>

<pre_code>range(start, stop, step)
</pre_code>

<p><inline_code>stop</inline_code> and <inline_code>step</inline_code> are optional. <inline_code>stop</inline_code> has to be addressed if <inline_code>step</inline_code> is defined. Take into account that, as for the slicing notation, the <inline_code>stop</inline_code> value is not included into the range created.</p>

<p>This function will make the iteration over a sequence of integer number easy and compact:</p>

<pre_code>for eachInt in range(10, 20, 2):
    print(eachInt)

# 10
# 12
# 14
# 16
# 18</pre_code>

<p>After the end of the loop the identifier will be still available in the program namespace, assigned to the last element of the iterable.</p>

<pre_code>for eachInt in range(10, 20, 2):
    print(eachInt)
print('-'*10)
print(eachInt)

# 10
# 12
# 14
# 16
# 18
# ----------
# 18</pre_code>


<p>How can this be useful in a graphic design application? Consider the following scenario: you would like to create a pdf document of sixteen pages and write on each page a sequential page number. Drawbot can do that of course:</p>

<large_image src="16pages.svg"></large_image>

<pre_code>pages = 16
for eachPageNumber in range(1, pages+1):
    newPage(200, 200)
    text('{}'.format(eachPageNumber), (20, 20))</pre_code>

<p>A for construct is the perfect companion of an <inline_code>.append() </inline_code>list method. It is very common to create a series of values starting from a pre-existing one. Like making an all-caps version of a word sequence:</p>

<pre_code>myWords = ['cat', 'table', 'sword']
myAllCapsWords = []
for eachWord in myWords:
    allCapsWord = eachWord.upper()
    myAllCapsWords.append(allCapsWord)
print(myAllCapsWords)
# ['CAT', 'TABLE', 'SWORD']</pre_code>

<section_title>Drawing Many Times in One Direction</section_title>

<p>Just like the <inline_code>while</inline_code> construct, <inline_code>for</inline_code> can be very helpful to draw shapes repetitively. In this way your code will look compact and it will be easy to edit.</p>

<p>Instead of:</p>

<code_image_wrapper><code_image src="4lines.png"></code_image>
<pre_code>size(100, 100)

stroke(0)
line((20, 20), (80, 20))
line((20, 40), (80, 40))
line((20, 60), (80, 60))
line((20, 80), (80, 80))</pre_code></code_image_wrapper><code_image>

<p>go for this structure</p>

<code_image_wrapper><code_image src="4lines.png"></code_image>
<pre_code>linesAmount = 4
size(100, 100)

stroke(0)
for eachLineIndex in range(linesAmount):
    # the width() function provides the canvas width in pts
    quota = width()/(linesAmount+1)*(eachLineIndex+1)
    line((20, quota), (80, quota))</pre_code></code_image_wrapper>

<p>The advantages of the second versionare enormous, starting for the very basic fact that you can add and subtract elements with almost no changes.</p>

<code_image_wrapper><code_image src="8lines.png"></code_image><pre_code>
linesAmount = 8
size(100, 100)

stroke(0)
for eachLineIndex in range(linesAmount):
    quota = width()/(linesAmount+1)*(eachLineIndex+1)
    line((20, quota), (80, quota))</pre_code></code_image_wrapper>

<p>What if you need to add points at the beginning and at the end? Easily done.</p>


<code_image_wrapper><code_image src="linesOvals.png"></code_image><pre_code>linesAmount = 8
radius = 3
size(100, 100)
for eachLineIndex in range(linesAmount):
    quota = width()/(linesAmount+1)*(eachLineIndex+1)
    fill(None)
    stroke(0)
    line((20, quota), (80, quota))
    
    stroke(None)
    fill(0)    
    oval(20-radius, quota-radius, radius*2, radius*2)
    oval(80-radius, quota-radius, radius*2, radius*2)
</pre_code></code_image_wrapper>

<p>Along with drawing, we can perform any kind of calculation. For example, the fill color of a shape could be defined by the identifier provided by the for construct. Here’s an example. </p>

<code_image_wrapper><code_image src="scaleGrey.png"></code_image><pre_code>shades = 10
size(100, 100)

shadeWidth = width()/shades
for shadeIndex in range(shades):
    grayscaleValue = 1 - (1/(shades-1)*shadeIndex)
    fill(grayscaleValue)
    rect(shadeIndex*shadeWidth, 0, shadeWidth, height())</pre_code></code_image_wrapper>

<p>Or we can affect the arguments used to draw the shape itself:</p>

<code_image_wrapper><code_image src="lines.png"></code_image><pre_code>linesAmount = 100
size(100, 100)
stroke(0)

factor = 1
for eachLineIndex in range(linesAmount):
    x = width()/(linesAmount+1)*(eachLineIndex+1) * factor
    line((x, 20), (x, 80))
    factor += .1</pre_code></code_image_wrapper>

<p>Remember that <inline_code>if</inline_code> statements can be used into the <inline_code>for</inline_code> body, meaning that we can perform choices within an iterative process:</p>

<code_image_wrapper><code_image src="stripes.png"></code_image><pre_code>stripes = 10
size(100, 100)

stripeWidth = width()/stripes
for stripeIndex in range(stripes):
    if stripeIndex % 2 == 0:
            fill(0)
    else:
            fill(1)
    rect(stripeIndex*stripeWidth, 0, stripeWidth, height())</pre_code></code_image_wrapper>

<section_title>Drawing Many Times in Two Directions</section_title>

<p>A single <inline_code>for</inline_code> construct allows repetition in one dimension. But, as we have seen with the previous example, other constructs can be used inside the for body. Which means that a second for loop can be nested into the first for loop. In this way the repetition becomes two dimensional.</p>

<p>If we need to draw a table or 90° based pattern, this technique becomes very handy. Consider the following drawing</p>

<large_image src="matrix.svg"></large_image>

<p>This is a bidimensional matrix, it is a simple table. Each element of the matrix is called cell. Each cell of this matrix can be described by two indexes: the index of the column and the row to which the cell belong. If we explicit write each index to each cell we obtain</p>

<large_image src="matrix-number.svg"></large_image>

<p>At this point we only need to define a size for the cell and we are able to draw the left column of the matrix</p>

<code_image_wrapper><code_image src="rows4.png"></code_image><pre_code>rows = 4
size(200, 200)

cellSize = height()/rows

stroke(0)
fill(None)
for rowIndex in range(rows):
    rect(0*cellSize, rowIndex*cellSize, cellSize, cellSize)</pre_code></code_image_wrapper>

<p>or the bottom row the matrix</p>

<code_image_wrapper><code_image src="cols4.png"></code_image><pre_code>cols = 4
size(200, 200)

cellSize = height()/cols

stroke(0)
fill(None)
for colIndex in range(cols):
    rect(colIndex*cellSize, 0*cellSize, cellSize, cellSize)</pre_code></code_image_wrapper>

<p>If we combine the two constructs together we can draw the entire matrix <em>calling</em> the <inline_code>rect()</inline_code> function only once</p>

<code_image_wrapper><code_image src="rowscols4.png"></code_image><pre_code>cols = 4
rows = 4
size(200, 200)

cellWidth = width()/cols
cellHeight = height()/rows

stroke(0)
fill(None)
for rowIndex in range(rows):
    for colIndex in range(cols):
        rect(colIndex*cellWidth, rowIndex*cellHeight, cellWidth, cellHeight)</pre_code></code_image_wrapper>

<p>Matrix indexes can be drawn very easily
</p>

<code_image_wrapper><code_image src="gridnumbers.png"></code_image><pre_code>cols = 4
rows = 4
size(200, 200)

cellWidth = width()/cols
cellHeight = height()/rows

for rowIndex in range(rows):
    for colIndex in range(cols):
        x = colIndex*cellWidth
        y = rowIndex*cellHeight

        stroke(None)
        fill(0)
        text('{}, {}'.format(colIndex, rowIndex), (x+5, y+5))

        fill(None)
        stroke(0)
        rect(x, y, cellWidth, cellHeight)</pre_code></code_image_wrapper>

<p>As for the single <inline_code>for</inline_code> construct, calculations performed within the body can affect the quality of the drawing. A one-dimensional gradient can easily become bi-dimensional</p>

<code_image_wrapper><code_image src="matrixRect.png"></code_image><pre_code>cols = 4
rows = 4
size(200, 200)
cellWidth = width()/cols
cellHeight = height()/rows
for rowIndex in range(rows):
    for colIndex in range(cols):
        grayscale = (rowIndex+colIndex)/(rows+cols-2)
        fill(grayscale)
        rect(colIndex*cellWidth, rowIndex*cellHeight, cellWidth, cellHeight)
</pre_code></code_image_wrapper>

<p>and an <inline_code>if</inline_code> statement nested into the inner <inline_code>for</inline_code> loop can draw a chess board:</p>

<code_image_wrapper><code_image src="chess.png"></code_image><pre_code>cols = 4
rows = 4
size(200, 200)
cellWidth = width()/cols
cellHeight = height()/rows
for rowIndex in range(rows):
    for colIndex in range(cols):
        if (rowIndex+colIndex) % 2 == 0:
            fill(0)
        else:
            fill(1)
        rect(colIndex*cellWidth, rowIndex*cellHeight, cellWidth, cellHeight)</pre_code></code_image_wrapper>

<p>Please, note that nested for constructs can also be used to navigate nested data structures as a list of tuples:</p>

<code_image_wrapper><code_image src="listprinted.png"></code_image><pre_code>myRoute = [(10.2, 22.3, (7, 51, 43)),
           (12.6, 19.8, (7, 52, 2)),
           (14.5, 18.2, (7, 52, 54))
           ]

leading = 18
cellWidth = 50

size(200, 200)
font('InputMono-Regular')
fontSize(14)

for indexRow, eachRow in enumerate(myRoute):
    for indexCell, cellContent in enumerate(eachRow):
        x = indexCell*cellWidth
        y = height() - (indexRow+1)*leading

        if indexCell == 2:
            text('{:0>2}:{:0>2}:{:0>2}'.format(*cellContent), (x, y))
        else:
            text('{}'.format(cellContent), (x, y))</pre_code></code_image_wrapper>
